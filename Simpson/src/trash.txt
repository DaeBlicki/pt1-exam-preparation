# ==================#
# simpson.cpp       #
# ==================#
/*
 * integrate() - use function pointer to integrate f(x) in interval (a, b) using simpson integration
 * PRECONDITIONS:   
 * @ f : is a pointer to a function with argument double x and return double f(x)
 * @ a : is start of the integration interval (a <= b)
 * @ b : is end of the integration interval (b >= a)
 * @ N : numbers of bins to split interval into smaller intervals (N > 0)
 * POST: return integration of function pointer in intervall (a, b) with N bins
 */
/*
double integrate( double (*f)(const double), const double a, const double b, const unsigned int N)
{
    Simpson::check_precondition(a, b, N);
    const unsigned int steps = 2*N + 1;
    const double dr = (b - a) / (steps - 1);
    double I = f(a);

    for(unsigned int i = 1; i < steps-1; ++i)
        I += 2 * (1.0 + i%2) * f(a + dr * i);

    I += f(b);
    return I * (1./3) * dr;
}
*/

/*
 * integrate() - use function class to integrate f(x) in interval (a,b) using simpson integration
 * PRECONDITIONS:   
 * @ f : is a simpson function class with defined operator()
 * @ a : is start of the integration interval (a <= b)
 * @ b : is end of the integration interval (b >= a)
 * @ N : numbers of bins to split interval into smaller intervals (N > 0)
 * POST: return integration of the function object in intervall (a, b) with N bins
 */
/*
double integrate(const Simpson::Function& f, const double a, const double b, const unsigned int N)
{
    Simpson::check_precondition(a, b, N);
    const unsigned int steps = 2*N + 1;
    const double dr = (b - a) / (steps - 1);
    double I = f(a);

    for(unsigned int i = 1; i < steps-1; ++i)
        I += 2 * (1.0 + i%2) * f(a + dr * i);

    I += f(b);
    return I * (1./3) * dr;
}
*/

# ==================#
# simpson.hpp       #
# ==================#

/*
 * integrate() - use function class to integrate f(x) in interval (a,b) using simpson integration
 * PRECONDITIONS:   
 * @ f : is a simpson function class with defined operator()
 * @ a : is start of the integration interval (a < b)
 * @ b : is end of the integration interval (b > a)
 * @ N : numbers of bins to split interval into smaller intervals (N > 0)
 * POST: return integration of the function object in intervall (a, b) with N bins
 */
double integrate( const Simpson::Function&, const double, const double, const unsigned int );

/*
 * integrate() - use function pointer to integrate f(x) in interval (a, b) using simpson integration
 * PRECONDITIONS:   
 * @ f : is a pointer to a function with argument double x and return double f(x)
 * @ a : is start of the integration interval (a < b)
 * @ b : is end of the integration interval (b > a)
 * @ N : numbers of bins to split interval into smaller intervals (N > 0)
 * POST: return integration of function pointer in intervall (a, b) with N bins
 */
// double integrate( double (*f)(const double), const double, const double, const unsigned int );